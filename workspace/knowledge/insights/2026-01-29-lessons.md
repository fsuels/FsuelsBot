---
updated: 2026-01-29
---

# Lessons Learned â€” 2026-01-29

## LESSON 1: Browser Automation Speed Ceiling

**Context:** Bot spent 20+ minutes trying to navigate Shopify code editor to make a 4-line LCP fix. Screenshots timed out, actions failed, each step took 5-15 seconds.

**Failure:** Attempting browser automation for tasks where human visual speed dominates. Human can look at page and click in 1 second; bot takes 5-15 seconds per step (screenshot â†’ process â†’ action â†’ wait â†’ repeat).

**Fix:** Redesign workflow division:
- Bot: research, writing, data, background grinding, memory
- Human: visual navigation, quick edits, familiar UIs
- Don't force bot to be "hands" when human's hands are faster

**Prevention:** Before starting browser automation, ask: "Is this a visual/quick task where human would be faster?" If yes, prepare the content/instructions and let human execute.

---

## LESSON 2: Step Tracking Prevents Context Loop Death

**Context:** Context truncation was causing bot to restart from step 1 instead of resuming from step 4, creating infinite loops.

**Failure:** Task progress lived only in conversation context, which gets compacted.

**Fix:** Each task in tasks.json now has `steps[]` array with `current_step` index. Bot persists progress BEFORE responding, reads on session start to resume correctly.

**Prevention:** For multi-step tasks, always use step tracking. Check `current_step` on session start. Never rely on conversation history for task progress.

---

## LESSON 3: Council Context Injection Is Mandatory

**Context:** Early Council sessions gave generic advice that didn't fit our system because AIs didn't know what we already had.

**Failure:** Asking "how do we improve X?" without showing what X currently looks like.

**Fix:** P0 protocol added to Council skill: Before ANY improvement question, paste relevant excerpts of current implementation (schemas, rules, constraints).

**Prevention:** Question template requires CONTEXT, WHAT'S WORKING, PROBLEM, CONSTRAINTS before the actual question. Never skip context injection.

---

## LESSON 4: Active-Thread Recovery Works

**Context:** Multiple context truncations today. Each time, reading `memory/active-thread.md` successfully restored working context.

**Failure:** N/A - this is a success validation.

**Fix:** The active-thread.md file serves as crash-recovery point. Validated in practice.

**Prevention:** Keep active-thread.md updated with current task, next step, and quick recovery instructions. Trust it when context is truncated.

---

## LESSON 5: Chat Commitments Must Hit Tasks.json Immediately

**Context:** Bot said "I'll do X" in chat, then context compacted and commitment was forgotten.

**Failure:** Verbal commitments in chat don't survive compaction.

**Fix:** Chat â†’ Queue Protocol: If bot commits to something, IMMEDIATELY write to tasks.json, read back to verify, then confirm with task ID.

**Prevention:** Trigger phrases ("I'll", "I will", "Sure", "Got it") must trigger immediate tasks.json write. Never confirm "Added to queue" without verified write.

---

## LESSON 6: Stop Grinding, Start Questioning (Francisco's Rule)

**Context:** Bot spent 20+ minutes fighting browser automation instead of stepping back after first few failures.

**Failure:** Stubbornly grinding through a bad approach instead of questioning whether it's the right tool.

**Fix:** New protocol â€” if something fails 2-3 times OR feels sluggish:
1. STOP grinding
2. Ask: "Is this the best tool for this?"
3. Ask: "Is there a faster/simpler approach?"
4. Ask: "Should the human do this instead?"
5. If recurring problem, escalate to workflow redesign (Council)

**Prevention:** Added "Recurring Problem Protocol" to SOUL.md. Don't be stubborn â€” step back, rethink, find the better path.

